---
layout: wiki
title: Models
wikiPageName: Models
menu: wiki
---

The purpose of running an experiment is to record data:
* what treatments are in your experiment, what games were played in those treatments,
* what the results were,
* what actions the players took, etc.

oTree stores your data in standard database tables (SQL), which you can later export to CSV for analysis in Stata, R, Matlab, Excel, etc.

For example, let's say you are programming an ultimatum game, where in each two-person group, one player makes a monetary offer (say, 0-100 cents), and another player either rejects or accepts the offer. When you analyze your data, you will want your "Group" table to look something like this:

    +----------+----------------+----------------+ 
    | Group ID | Amount offered | Offer accepted |
    +==========+================+================+
    | 1        | 50             | TRUE           |
    +----------+----------------+----------------+ 
    | 2        | 25             | FALSE          |
    +----------+----------------+----------------+ 
    | 3        | 50             | TRUE           |
    +----------+----------------+----------------+ 
    | 4        | 0              | FALSE          |
    +----------+----------------+----------------+ 
    | 5        | 60             | TRUE           |
    +----------+----------------+----------------+ 

In order to end up with this table schema, you need to define a Django model, which is a Python class that defines a database table. You define what fields (columns) are in the table, what their data types are, and so on. When you run your experiment, the SQL tables will get automatically generated, and each time users visit, new rows will get added to the tables.

Here is what the model might look like for the above "Group" table::

    class Group(otree.models.BaseGroup):
        ...
        amount_offered = models.CurrencyField()
        offer_accepted = models.NullBooleanField()
    
This class will be placed in your app's `models.py` file.

Every oTree app needs the following 3 models:

* Player
* Group
* Subsession

They are related to each other as follows:

A player is part of a group, which is part of a subsession.

### Technical details
Each model has pointers to the parent models. A player object has attributes called `group` and `subsession`; a group object has a `subsession`.

Each model also has pointers to its child models. A `subsession` has methods called `get_players()`, and `get_groups()`. For example, entering `.get_players()` on a subsession will return a list of player contained in that subsession. Likewise, a group has a `get_players()` method.

Each model field you define can also have a `doc=` argument. Any string you add here will be included in the autogenerated documentation file, which can be downloaded through the data export page in the admin.

### Constants
`Constants` is a place to put your app's parameters and other constants.

These constants are required:
* `players_per_group` should be set to the number of players in a group of this game type. For example, in a 2-player game like an ultimatum game or prisoner's dilemma, you would set this to 2. If your app does not involve dividing the players into multiple groups, then set it to `None`. e.g. it is a single-player game or an auction where everybody in the subsession interacts together as 1 group. In this case, `self.group.get_players()` will return everybody in the subsession.
* `num_rounds` is the number of rounds this game should be played
* `name_in_url` is an attribute that defines the name this app has in the URLs, which players may see.


### Player

A player represents a person who participates in the subsession. The player object will store the results of that player's actions.

#### Implementation

The `payoff` field stores the monetary payoff the player gets paid for the current subsession (meaning `self.payoff = 1.20` sets the payoff to $1.20 (or, depending on your currency code, â‚¬1.20, etc.). You should set the payoff at some point in the subsession, usually on a wait page before the results page, when the player has fully completed their task. A good practice is to have a method on the group called `set_payoffs()` and call this method in the last wait page.

The field `id_in_group` is an index starting from 1. This is useful in multiplayer games where players have different roles, so that you can determine if the player is player 1, player 2, or so on.

The methods `get_others_in_group()` and `get_others_in_subsession()` returns a list of the other players in the group and subsession, respectively.

### Group

Groups represent multiplayer games, where there is some interaction between players. Example of a group: "an ultimatum game between players Alice and Bob, where Alice gave offered to give $0.50".

On your group model you can define fields to store the results of a particular group (e.g. what the score was).

Groups have a method called `get_player_by_id()`. The argument to this method is an integer; this function retrieves the player in the group whose `id_in_group` is that integer. So to get player 1 in a group, you would do `p1 = self.group.get_player_by_id()`.

There is also a similar method `get_player_by_role()`. The argument to this method is a string that looks up the player by their role value. (If you use this method, you must define the `role` method on the player model, which should return a string that depends on `id_in_group`.)

### Subsession

Your subsession model can define any fields that are common to all players in the subsession.

### Validation

oTree automatically validates all input submitted by the user.
For example, if you have a form containing a `PositiveIntegerField`,
oTree will not let the user submit values that are not positive integers, like `-1`, `1.5`, or `hello`.

Additionally, you can define one of the below methods.

#### `def {field_name}_bounds(self)`

If you want to constrain the allowable answers for a field to a numeric range, you can define this method,
which should return a list with 2 elements, specifying the lower and upper bounds,  e.g. `return [24, 48]`

#### `def {field_name}_choices(self)`

If this method is defined, the default form widget will be a select box with these choices instead of the standard text field. This should return a list of values. If you would like a specially formatted value displayed to the user, you can return a list consisting itself of tuples of exactly two items (e.g. [(A, B), (A, B) ...]) to use as choices for this field. The first element in each tuple is the actual value to be set on the model, and the second element is the human-readable name. For example:

    def year_in_school_choices(self):
        return [
            ('FR', 'Freshman'),
            ('SO', 'Sophomore'),
            ('JR', 'Junior'),
            ('SR', 'Senior'),
    ]


#### `def {field_name}_error_message(self, value)`


Additionally, You can define a method called `[your field name]_error_message` that does additional validation of any form field.

For example, let's say your form has a field called `amount_returned`, which cannot be greater than the group's `amount_offered`. You would enforce this as follows:

    def amount_returned_error_message(self, value):
        if value > self.group.amount_offered:
            return 'Amount returned cannot be greater than amount offered'
